using UnityEngine;
using TMPro;
using System.Collections;
using System.Collections.Generic;

public class GameBoardView : MonoBehaviour
{
    [Header("Model + Prefabs")]
    public GamePlayModel model;
    public GameObject backgroundTilePrefab; // Пустая подложка
    public GameObject valueTilePrefab;      // Плитка со значением

    [Header("UI Links")]
    public RectTransform boardContainer;
    public TextMeshProUGUI scoreText;
    public TextMeshProUGUI messageText;

    [Header("Board Settings")]
    [SerializeField] private float tileSize = 100f;
    [SerializeField] private float spacing = 10f;

    private GameObject[,] backgroundTiles; // Статичные подложки
    private TileView[,] valueTiles;        // Плитки со значениями
    private bool isAnimating = false;

    void Start()
    {
        InitBoard();
        Refresh();
    }

    private void InitBoard()
    {
        backgroundTiles = new GameObject[model.Size, model.Size];
        valueTiles = new TileView[model.Size, model.Size];

        float boardSize = model.Size * tileSize + (model.Size - 1) * spacing;
        float startX = -boardSize / 2f + tileSize / 2f;
        float startY = boardSize / 2f - tileSize / 2f;

        // Создаём фоновые подложки
        for (int r = 0; r < model.Size; r++)
        {
            for (int c = 0; c < model.Size; c++)
            {
                GameObject bgTile = Instantiate(backgroundTilePrefab, boardContainer);
                RectTransform rect = bgTile.GetComponent<RectTransform>();

                rect.anchorMin = new Vector2(0.5f, 0.5f);
                rect.anchorMax = new Vector2(0.5f, 0.5f);
                rect.pivot = new Vector2(0.5f, 0.5f);
                rect.sizeDelta = new Vector2(tileSize, tileSize);

                float x = startX + c * (tileSize + spacing);
                float y = startY - r * (tileSize + spacing);
                rect.anchoredPosition = new Vector2(x, y);

                backgroundTiles[r, c] = bgTile;
            }
        }

        // Создаём плитки со значениями (изначально все скрыты)
        for (int r = 0; r < model.Size; r++)
        {
            for (int c = 0; c < model.Size; c++)
            {
                GameObject valueTile = Instantiate(valueTilePrefab, boardContainer);
                RectTransform rect = valueTile.GetComponent<RectTransform>();

                rect.anchorMin = new Vector2(0.5f, 0.5f);
                rect.anchorMax = new Vector2(0.5f, 0.5f);
                rect.pivot = new Vector2(0.5f, 0.5f);
                rect.sizeDelta = new Vector2(tileSize, tileSize);

                float x = startX + c * (tileSize + spacing);
                float y = startY - r * (tileSize + spacing);
                rect.anchoredPosition = new Vector2(x, y);

                TileView tv = valueTile.GetComponent<TileView>();
                tv.SetValue(0); // Скрываем
                valueTiles[r, c] = tv;
            }
        }
    }

    // Получить позицию ячейки [r, c]
    private Vector2 GetCellPosition(int r, int c)
    {
        return backgroundTiles[r, c].GetComponent<RectTransform>().anchoredPosition;
    }

    public void Refresh()
    {
        RefreshWithAnimation(false);
    }

    public void RefreshWithAnimation(bool animate = true)
    {
        if (isAnimating) return;

        if (animate && model.LastMoves.Count > 0)
        {
            StartCoroutine(AnimateMoves());
        }
        else
        {
            RefreshImmediate();
        }
    }

    private void RefreshImmediate()
    {
        // Обновляем все плитки согласно модели БЕЗ анимации
        for (int r = 0; r < model.Size; r++)
        {
            for (int c = 0; c < model.Size; c++)
            {
                valueTiles[r, c].SetValue(model.Board[r, c], false); // false - без анимации
                valueTiles[r, c].GetComponent<RectTransform>().anchoredPosition = GetCellPosition(r, c);
            }
        }

        UpdateUI();
    }

    private IEnumerator AnimateMoves()
    {
        isAnimating = true;

        // Сначала скрываем все плитки, которые будут двигаться
        foreach (var move in model.LastMoves)
        {
            if (move.from != move.to)
            {
                valueTiles[move.from.x, move.from.y].SetValue(0, false);
            }
        }

        int completedMoves = 0;
        int totalMoves = model.LastMoves.Count;

        // Запускаем все анимации параллельно
        foreach (var move in model.LastMoves)
        {
            Vector2 fromPos = GetCellPosition(move.from.x, move.from.y);
            Vector2 toPos = GetCellPosition(move.to.x, move.to.y);

            TileView movingTile = valueTiles[move.from.x, move.from.y];

            // Устанавливаем начальную позицию и значение
            movingTile.GetComponent<RectTransform>().anchoredPosition = fromPos;

            if (move.isMerge)
            {
                movingTile.SetValue(move.value, false); // Показываем исходное значение
            }
            else
            {
                movingTile.SetValue(move.value, true); // Показываем финальное значение
            }

            // Анимируем движение
            StartCoroutine(AnimateSingleMove(movingTile, fromPos, toPos, move, () =>
            {
                completedMoves++;
            }));
        }

        // Ждём завершения всех анимаций
        while (completedMoves < totalMoves)
        {
            yield return null;
        }

        // Синхронизируем финальное состояние БЕЗ анимации для всех плиток
        for (int r = 0; r < model.Size; r++)
        {
            for (int c = 0; c < model.Size; c++)
            {
                valueTiles[r, c].SetValue(model.Board[r, c], false); // false - без анимации
                valueTiles[r, c].GetComponent<RectTransform>().anchoredPosition = GetCellPosition(r, c);
            }
        }

        yield return new WaitForSeconds(0.05f);

        // Анимируем появление только НОВОЙ плитки
        if (model.NewTilePosition.HasValue)
        {
            Vector2Int newPos = model.NewTilePosition.Value;
            valueTiles[newPos.x, newPos.y].SetValue(model.Board[newPos.x, newPos.y], true); // true - с анимацией
            valueTiles[newPos.x, newPos.y].AnimateSpawn();
        }

        UpdateUI();
        isAnimating = false;
    }

    private IEnumerator AnimateSingleMove(TileView tile, Vector2 fromPos, Vector2 toPos, GamePlayModel.TileMove move, System.Action onComplete)
    {
        // Анимация движения
        yield return StartCoroutine(tile.AnimateMoveCoroutine(fromPos, toPos));

        // Если это слияние - анимируем scale pop
        if (move.isMerge)
        {
            // Обновляем значение на целевой плитке
            valueTiles[move.to.x, move.to.y].SetValue(move.mergedValue, false); // Без анимации fade
            valueTiles[move.to.x, move.to.y].AnimateScalePop();

            // Скрываем движущуюся плитку
            tile.SetValue(0, false);
        }

        onComplete?.Invoke();
    }

    private void UpdateUI()
    {
        scoreText.text = model.Score.ToString();
        messageText.text = model.IsGameOver ? "Game Over!" : "";
    }
}
using UnityEngine;

public class GameController : MonoBehaviour
{
    [SerializeField] private GameBoardView view;

    private GamePlayModel model;

    void Awake()
    {
        model = new GamePlayModel(4);
    }

    private void Start()
    {
        view.model = model;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.LeftArrow)) MakeMove(Vector2Int.left);
        if (Input.GetKeyDown(KeyCode.RightArrow)) MakeMove(Vector2Int.right);
        if (Input.GetKeyDown(KeyCode.UpArrow)) MakeMove(Vector2Int.up);
        if (Input.GetKeyDown(KeyCode.DownArrow)) MakeMove(Vector2Int.down);

        // Отладочная перезагрузка
        if (Input.GetKeyDown(KeyCode.R))
        {
            OnRestartButton();
        }
    }

    private void MakeMove(Vector2Int dir)
    {
        bool moved = model.Move(dir);
        if (moved)
        {
            // Используем анимированное обновление
            view.RefreshWithAnimation(true);
        }
    }

    public void OnRestartButton()
    {
        model.Reset();
        view.Refresh();
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GamePlayModel
{
    public int Size { get; private set; } = 4;
    public int[,] Board { get; private set; }
    public int Score { get; private set; }
    public bool IsGameOver { get; private set; }

    // Для анимации
    public class TileMove
    {
        public Vector2Int from;
        public Vector2Int to;
        public int value;
        public bool isMerge;
        public int mergedValue; // значение после слияния
    }
    public Vector2Int? NewTilePosition { get; private set; } = null; // Позиция новой плитки

    public List<TileMove> LastMoves { get; private set; } = new List<TileMove>();

    private System.Random rng = new System.Random();

    public GamePlayModel(int size = 4)
    {
        Size = size;
        Board = new int[size, size];
        Reset();
    }

    public void Reset()
    {
        Score = 0;
        IsGameOver = false;
        Array.Clear(Board, 0, Board.Length);
        LastMoves.Clear();
        NewTilePosition = null;
        SpawnTile();
        SpawnTile();
    }

    public bool Move(Vector2Int dir)
    {
        if (IsGameOver) return false;
        LastMoves.Clear();
        NewTilePosition = null;

        bool moved = false;
        bool[,] merged = new bool[Size, Size];

        // Определяем порядок обхода в зависимости от направления
        int startRow = dir.y > 0 ? Size - 1 : 0;
        int endRow = dir.y > 0 ? -1 : Size;
        int stepRow = dir.y > 0 ? -1 : 1;

        int startCol = dir.x > 0 ? Size - 1 : 0;
        int endCol = dir.x > 0 ? -1 : Size;
        int stepCol = dir.x > 0 ? -1 : 1;

        // Временный список для отслеживания движений
        List<TileMove> tempMoves = new List<TileMove>();

        for (int r = startRow; r != endRow; r += stepRow)
        {
            for (int c = startCol; c != endCol; c += stepCol)
            {
                if (Board[r, c] == 0) continue;

                int currentR = r;
                int currentC = c;
                Vector2Int startPos = new Vector2Int(r, c);
                int tileValue = Board[r, c];
                bool movedThisTile = false;
                Vector2Int finalPos = startPos;

                // Двигаем плитку пока возможно
                while (true)
                {
                    int nextR = currentR - dir.y;
                    int nextC = currentC + dir.x;

                    // Проверяем границы
                    if (nextR < 0 || nextR >= Size || nextC < 0 || nextC >= Size)
                        break;

                    // Если следующая ячейка пустая - перемещаемся
                    if (Board[nextR, nextC] == 0)
                    {
                        Board[nextR, nextC] = Board[currentR, currentC];
                        Board[currentR, currentC] = 0;
                        currentR = nextR;
                        currentC = nextC;
                        finalPos = new Vector2Int(currentR, currentC);
                        movedThisTile = true;
                        moved = true;
                    }
                    // Если следующая ячейка содержит такую же плитку и не была объединена - объединяем
                    else if (Board[nextR, nextC] == Board[currentR, currentC] && !merged[nextR, nextC])
                    {
                        int newValue = Board[nextR, nextC] * 2;
                        Board[nextR, nextC] = newValue;
                        Board[currentR, currentC] = 0;
                        Score += newValue;
                        merged[nextR, nextC] = true;
                        movedThisTile = true;
                        moved = true;

                        tempMoves.Add(new TileMove
                        {
                            from = startPos,
                            to = new Vector2Int(nextR, nextC),
                            value = tileValue,
                            isMerge = true,
                            mergedValue = newValue
                        });
                        break;
                    }
                    else
                    {
                        // Не можем двигаться дальше
                        break;
                    }
                }

                // Если плитка двигалась но не объединялась
                if (movedThisTile && finalPos != startPos)
                {
                    // Проверяем, не было ли уже добавлено движение слияния для этой плитки
                    bool alreadyAddedAsMerge = tempMoves.Any(m => m.from == startPos && m.isMerge);

                    if (!alreadyAddedAsMerge)
                    {
                        tempMoves.Add(new TileMove
                        {
                            from = startPos,
                            to = finalPos,
                            value = tileValue,
                            isMerge = false
                        });
                    }
                }
            }
        }

        // Переносим временные движения в основной список
        LastMoves.AddRange(tempMoves);

        if (moved)
        {
            SpawnTile();
            if (CheckGameOver()) IsGameOver = true;
        }
        return moved;
    }

    private void SpawnTile()
    {
        List<Vector2Int> empties = new List<Vector2Int>();
        for (int r = 0; r < Size; r++)
            for (int c = 0; c < Size; c++)
                if (Board[r, c] == 0)
                    empties.Add(new Vector2Int(r, c));

        if (empties.Count == 0) return;

        Vector2Int pick = empties[rng.Next(empties.Count)];
        Board[pick.x, pick.y] = rng.NextDouble() < 0.9 ? 2 : 4;
        NewTilePosition = pick; // Запоминаем позицию новой плитки!
    }

    private bool CheckGameOver()
    {
        for (int r = 0; r < Size; r++)
        {
            for (int c = 0; c < Size; c++)
            {
                if (Board[r, c] == 0) return false;
                if (r + 1 < Size && Board[r, c] == Board[r + 1, c]) return false;
                if (c + 1 < Size && Board[r, c] == Board[r, c + 1]) return false;
            }
        }
        return true;
    }

    public void PrintDebug()
    {
        string s = "";
        for (int r = 0; r < Size; r++)
        {
            for (int c = 0; c < Size; c++)
                s += Board[r, c].ToString().PadLeft(5);
            s += "\n";
        }
        Debug.Log(s + $"Score: {Score}");
    }
}
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class TileView : MonoBehaviour
{
    [SerializeField] private Image background;
    [SerializeField] private TextMeshProUGUI valueText;
    [SerializeField] private float moveSpeed = 1500f; // пиксели в секунду
    [SerializeField] private float scaleAnimDuration = 0.15f;

    private int value;
    private RectTransform rectTransform;
    private Coroutine currentAnimation;

    private void Awake()
    {
        rectTransform = GetComponent<RectTransform>();
    }

    public void SetValue(int newValue, bool animate = false)
    {
        value = newValue;

        if (value == 0)
        {
            // Плитка пустая - делаем невидимой через прозрачность
            valueText.text = "";
            background.color = new Color32(0, 0, 0, 0);
            // Не отключаем GameObject чтобы не прерывать анимации
        }
        else
        {
            valueText.text = value.ToString();

            // ВАЖНО: Всегда устанавливаем правильный цвет текста и фона
            Color32 tileColor = GetColor(value);
            valueText.color = GetColor(value);
            background.color = tileColor;

            if (animate)
            {
                // Плавное появление
                if (currentAnimation != null)
                    StopCoroutine(currentAnimation);
                currentAnimation = StartCoroutine(FadeInCoroutine(tileColor));
            }
            else
            {
                // Мгновенное отображение - устанавливаем полную непрозрачность
                background.color = tileColor;
                valueText.color = GetColor(value);
            }
        }
    }

    // Анимация движения
    public void AnimateMove(Vector2 targetPosition, bool isMerge, System.Action onComplete = null)
    {
        if (currentAnimation != null)
            StopCoroutine(currentAnimation);

        currentAnimation = StartCoroutine(AnimateMoveCoroutine(rectTransform.anchoredPosition, targetPosition, onComplete));
    }

    public IEnumerator AnimateMoveCoroutine(Vector2 fromPosition, Vector2 toPosition, System.Action onComplete = null)
    {
        Vector2 startPosition = fromPosition;
        float distance = Vector2.Distance(startPosition, toPosition);
        float duration = distance / moveSpeed;

        // Минимальная и максимальная длительность
        duration = Mathf.Clamp(duration, 0.05f, 0.3f);

        float elapsed = 0f;

        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float t = Mathf.Clamp01(elapsed / duration);

            // Ease-out cubic для плавности
            t = 1f - Mathf.Pow(1f - t, 3f);

            rectTransform.anchoredPosition = Vector2.Lerp(startPosition, toPosition, t);
            yield return null;
        }

        rectTransform.anchoredPosition = toPosition;
        currentAnimation = null;
        onComplete?.Invoke();
    }

    // Анимация pop при слиянии
    public void AnimateScalePop()
    {
        if (currentAnimation != null)
            StopCoroutine(currentAnimation);

        currentAnimation = StartCoroutine(ScaleAnimation());
    }

    // Анимация появления новой плитки
    public void AnimateSpawn()
    {
        if (currentAnimation != null)
            StopCoroutine(currentAnimation);

        currentAnimation = StartCoroutine(SpawnCoroutine());
    }

    private IEnumerator SpawnCoroutine()
    {
        transform.localScale = Vector3.zero;

        // Убедимся, что цвет установлен правильно перед анимацией
        if (value != 0)
        {
            Color32 tileColor = GetColor(value);
            background.color = tileColor;
            valueText.color = GetColor(value);
        }

        float elapsed = 0f;

        while (elapsed < scaleAnimDuration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / scaleAnimDuration;

            // Ease-out с небольшим overshoot
            t = 1f - Mathf.Pow(1f - t, 2f);
            float scale = Mathf.Lerp(0f, 1.1f, t);

            transform.localScale = Vector3.one * scale;
            yield return null;
        }

        // Небольшой bounce назад
        elapsed = 0f;
        float bounceTime = 0.05f;

        while (elapsed < bounceTime)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / bounceTime;
            float scale = Mathf.Lerp(1.1f, 1f, t);
            transform.localScale = Vector3.one * scale;
            yield return null;
        }

        transform.localScale = Vector3.one;
        currentAnimation = null;
    }

    // Анимация "pop" при слиянии
    private IEnumerator ScaleAnimation()
    {
        float elapsed = 0f;
        float halfDuration = scaleAnimDuration / 2f;

        // Увеличиваем
        while (elapsed < halfDuration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / halfDuration;
            transform.localScale = Vector3.Lerp(Vector3.one, Vector3.one * 1.2f, t);
            yield return null;
        }

        elapsed = 0f;
        // Уменьшаем обратно
        while (elapsed < halfDuration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / halfDuration;
            transform.localScale = Vector3.Lerp(Vector3.one * 1.2f, Vector3.one, t);
            yield return null;
        }

        transform.localScale = Vector3.one;
        currentAnimation = null;
    }

    private IEnumerator FadeInCoroutine(Color32 targetColor)
    {
        Color32 startColor = new Color32(targetColor.r, targetColor.g, targetColor.b, 0);
        Color32 targetTextColor = GetColor(value);
        Color32 startTextColor = new Color32(targetTextColor.r, targetTextColor.g, targetTextColor.b, 0);

        float elapsed = 0f;
        while (elapsed < scaleAnimDuration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / scaleAnimDuration;

            // Анимируем прозрачность фона и текста
            background.color = Color.Lerp(startColor, targetColor, t);
            valueText.color = Color.Lerp(startTextColor, targetTextColor, t);
            yield return null;
        }

        background.color = targetColor;
        valueText.color = targetTextColor;
        currentAnimation = null;
    }

    private Color32 GetColor(int val)
    {
        switch (val)
        {
            case 2: return new Color32(0, 180, 255, 255);
            case 4: return new Color32(255, 150, 60, 255);
            case 8: return new Color32(255, 70, 180, 255);
            case 16: return new Color32(255, 50, 120, 255);
            case 32: return new Color32(0, 255, 180, 255);
            case 64: return new Color32(0, 255, 255, 255);
            case 128: return new Color32(255, 200, 50, 255);
            case 256: return new Color32(255, 100, 255, 255);
            case 512: return new Color32(150, 100, 255, 255);
            case 1024: return new Color32(80, 160, 255, 255);
            case 2048: return new Color32(255, 255, 255, 255);
            default: return new Color32(30, 30, 60, 255);
        }
    }
}
